- [x] 关于学习的真谛在于“用”。先学再用，先用再学。一定要尝试，要用。
- [ ] 完成一个 Angular 项目
- [ ] coffeeScript
- [ ] webpack
- [ ] gulp
- [ ] Node.js
- [ ] Backbone
- [ ] backbone + underscore
- [ ] My.js
- [ ] FibJS 一个是否比 NodeJS 更优秀的服务端 js 编程框架
- [ ] 关于 http://www.bootcss.com/ 的学习
- [ ] 腾讯Alloy Team 团队 Kinvix[a]QQ.com
- [ ] layui -- 最懂你的弹窗 -- 基于jq -- 满足你所有想要的弹窗
- [ ] [前端的一些汇总](https://github.com/helloqingfeng)
- [ ] 写简历
- [ ] TypeScript
- [ ] ES6
- [ ] 编辑器 Sublime Atom WebStorm
- [ ] [egg](https://egghead.io/)



1.跟LESS和Sass让书写CSS变得更容易一样,CoffeeScript简化了书写JavaScript的方式。
2.项目管理工具：gulp,grunt,webpack、Node.js，PHP，Angular，Gulp，Webpack。
3.了解backbone,Underscore,angular,react,vue,ember,jQuery、sass、CoffeeScript、Bootstrap等；
4.koala是一个前端预处理器语言图形编辑工具，支持Less,sass,compass,coffeescript,帮助web开发者更高效的使用它们进行开发。跨平台运行，完美兼容windows,linux,mac。
5.backbone 关于 backbone 的一篇 slide [https://speakerdeck.com/edokeh/backbone-kai-fa-shi-zhan](https://speakerdeck.com/edokeh/backbone-kai-fa-shi-zhan)
6.《锋利的jQuery》342页的浏览器中的调试以及断点，值得学习，总结一篇blog。

modernizr.js是和HTML5Shiv差不多的，貌似比HTML5Shiv好一些，也不知道是不是真的。
As of Modernizr 1.5,this script is identical to what is used in the popular html5shim/html5shiv library.

html5shiv主要是针对IE，Modernizr是支持全系列
html5shiv主要是为IE添加HTML5标签支持，而Modernizr则是检测浏览器对HTML5/CSS3的支持情况，并将结果添加到html的css中。

官网[http://modernizr.com/download/](http://modernizr.com/download/)默认是把html5shiv勾选的，如果没勾选，下载的版本就没有html5shiv。
[Modernizr.js入门指南](http://www.tuicool.com/articles/UVnEVj)



----------------------------------------

[关于浏览器同源政策及其规避方法，做为前端，你不得不知道](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)

[跨域资源共享CORS详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

[jquery中ajax处理跨域的三大方式](http://www.jb51.net/article/77470.htm)
[跨域的另一种解决方案--CORS--Cross-Origin Resource Sharing](http://www.cnblogs.com/shikyoh/p/4959562.html)

[AJAX 跨域技术 汇总](http://www.jb51.net/Special/894.htm)

跨域
--
浏览器会进行同源检查（看清楚，这里是浏览器会进行同源检测。）,这导致了跨域问题,然而这个跨域检查还有一个例外那就是HTML的<Script>标记;我们经常使用<Script>的src属性,脚本静态资源放在独立域名下或者来自其它站点的时候这里是一个url;这个url响应的结果可以有很多种,比如JSON,返回的Json值成为<Script>标签的src属性值.这种属性值变化并不会引起页面的影响.按照惯例，浏览器在URL的查询字符串中提供一个参数，这个参数将作为结果的前缀一起返回到浏览器;

------------------------------------------------------




关于博客评论区的用户标识颜色块的制作，[https://jetyu.github.io/2016/11/04/20161104/](https://jetyu.github.io/2016/11/04/20161104/)
博客中引入了 `embed.js` ，来源是 所说的静态文件。
引入的地方是： `\next\layout\_scripts\third-party\comments\duoshuo.swing` 9-20行。
现在要做的是 将这个 `embed.js` 文件本地化，也就是说将 `embed.js` 放到咋们自己的目录结构下面来，然后还要对其做一点小改动。

在做这个UA样式之前，我们先把之前的多说CSS样式写到本地的 `custom.styl` 下来。
然后参考一下这个：[https://wsgzao.github.io/post/duoshuo/#%E6%9C%AC%E5%9C%B0%E5%8C%96embed-js](https://wsgzao.github.io/post/duoshuo/#%E6%9C%AC%E5%9C%B0%E5%8C%96embed-js)，看一下图像水平翻转要不要。

然后就是本地化 `embed.js` ，[这篇文章](https://jetyu.me/2014/04/24/20140424/#comments)也有提到本地化embed.js的做法，结合两篇文章，搞一下这个本地化 `embed.js`。

最后就是 多说后台自定义 CSS ，我们还是放在自己的本地 `custom.styl` 下。

最后还有这篇：[[多说]不本地化embed.js使多说评论显示UA](http://easun.org/blog/archives/make_duoshuo_show_ua.html)





关于一些作者草稿区中的文章[https://github.com/yalishizhude/Github-blog/tree/master/source/_drafts](https://github.com/yalishizhude/Github-blog/tree/master/source/_drafts)



在博客中的某篇文章中添加脚本：
```
{% raw %}
content
{% endraw %}
```
这样真的可以吗？



JavaScript内存泄漏的问题
[http://zouzaibianyuan.iteye.com/blog/1933904](http://zouzaibianyuan.iteye.com/blog/1933904)
[http://blog.csdn.net/li2274221/article/details/25217297](http://blog.csdn.net/li2274221/article/details/25217297)
[http://www.2cto.com/kf/201402/281855.html](http://www.2cto.com/kf/201402/281855.html)
[http://www.jb51.net/article/54775.htm](http://www.jb51.net/article/54775.htm)


垃圾回收机制——GC
JavaScript 具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。

原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。

JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。

不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配响应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。

还是上代码说明吧：
``` javascript
function fn1() {
    var obj = {name: 'yu', age: 10};
} 
function fn2() {
    var obj = {name: 'yu', age: 11};
    return obj;
}
var a = fn1();
var b = fn2();
```
我们来看代码是如何执行的。首先定义了两个function,分别叫做fn1和fn2，当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。

这里问题就出现了：到底哪个变量时没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。

二、标记清除
js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个而变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

三、Netscape Navigator3是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。
``` javascript
function fn() {
    var a = {};
    var b = {};
    a.pro = b;
    b.pro = a;
} 
fn();
```
以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄漏。在IE7与IE8上，内存直线上升。
最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样
``` javascript
myObject.element = null;
element.o = null;
```

四、内存管理
1、什么时候触发垃圾回收？
垃圾回收周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64K的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好嘛？但是如果环境中就是有这么多变量一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法玩了。

微软在IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%,说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临界条件翻倍，如果回收的内存高于85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作智能了很多

2、合理的GC方案
1)、JavaScript引擎基础GC方案是(simple GC)：mark and sweep(标记清除)，即：
    (1) 遍历所有可访问的对象。
    (2) 回收已不可访问的对象。

2）、GC的缺陷
和其他语言一样，JavaScript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而JavaScript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。

总结
一般不用setInterval，而用setTimeout的延时递归来代替interval。
setInterval会产生回调堆积，特别是时间很短的时候。


setInterval有个很烦的地方就是当js主程序空闲的时候，执行代码队列里面的代码的时候，如果此时候我们有一个问题，定时器是等到回调执行完，才开始计时进行下次循环呢？还是只要一次计时完毕，插入回调之后不管回调执不执行就开始计时呢？答案显示是后者，这也就是我说setInterval坑比的原因啊，因为这会出现一种情况，当我们插入回调的时候前队列有别的代码在执行，这时候回调肯定是不会执行的，因此如果这个时候无限定时时间到了会再次插入回调，这个时候如果发现队列中的第一次回调没有执行，那么再次插入的回调浏览器就默认取消，（这是以防出现回调连续执行多次的情况）但是这又引发了新的情况就是有些回调是不能取消掉的？
-------






[slidejs](http://slidesjs.com/)
[jquery.fullpage.min.js](http://www.dowebok.com/demo/2014/77/)














js - onclick和addEventListener和attachEvent有什么区别呢？
本质的区别是el.onclick相当于在标签上写onclick，用addEventListener和attachEvent是通过DOM接口去绑定事件。
一个html文档的解析是有顺序的，先解析标签项，再解析DOM项，el.onlick事实上相当于写在标签页上，通过标签的onclick属性输入到文档，然后由文档解析成事件的。而后者，要在文档解析完成以后，通过文档的dom接口去绑定的事件，虽然结果是一样的，都是click事件，但是过程是不同的。

通过这三种方式绑定的事件，怎么取消呢？
el.onclick: el.onclick = null;这样就可以取消绑定在el上的事件处理程序了。
通过addEventListener()添加的事件处理程序只能通过removeEventListener()来移除，并且移除时传入的参数与添加处理程序时使用的参数相同。通过addEventListener()添加的匿名函数将无法移除。
通过attachEvent()添加的事件处理程序要通过detachEvent()来移除，其他的情况和addEventListener()一样。


如果都想在事件函数里面获取event对象，怎么获取呢？
这要分浏览器，IE和非IE的事件对象不同。兼容DOM的浏览器会将一个event对象传入到事件处理程序中，无论指定事件处理程序时使用什么方法，都会传入event对象。
```
el.onclick = function(event) {
    alert(event.type);  //'click'
}
el.addEventListener("click",function(event) {
    alert(event.type);  //'click'
},false);
```

通过HTML标签属性指定的事件处理程序时，变量event中保存着event对象。
`<input type="button" value="Click me" onclick="alert(event.type)/>  //"click"`
在IE中，要访问event对象有几种不同的方式：
通过el.onclick绑定的事件处理程序中，event对象作为window对象的一个属性存在。
```
el.onclick = function() {
    var event = window.event;
    alert(event.type);  //"click"
}
```
如果通过attachEvent()添加事件处理程序时，event对象作为参数被传入事件处理程序，
```
el.attachEvent("onclick",function(event) {
    alert(event.type);  //"click"
});
```
通过HTML标签属性指定的事件处理程序时，变量event中保存着event对象。这点和非IE一样。
综上，跨浏览器的事件对象获取方法是：return event?event:window.event;




移动端web app是什么呢？简单理解就是页面头部加入了下面这一句话的东西：
```
<meta name="apple-mobile-web-app-capable" content="yes">
```
这个meta的作用是让普通移动网页被添加到主屏幕后，拥有一些类native的功能，很多同学应该都很熟悉了。就是类似隐藏ios的上下状态栏，实现全屏，禁止弹性拖拽，全屏，修改顶部颜色等。















