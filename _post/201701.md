- [x] 关于学习的真谛在于“用”。先学再用，先用再学。一定要尝试，要用。
- [ ] 完成一个 Angular 项目
- [ ] coffeeScript
- [ ] webpack
- [ ] gulp
- [ ] Node.js
- [ ] Backbone
关于 backbone 的一篇 slide [https://speakerdeck.com/edokeh/backbone-kai-fa-shi-zhan](https://speakerdeck.com/edokeh/backbone-kai-fa-shi-zhan)
- [ ] backbone + underscore
- [ ] My.js
- [ ] FibJS 一个是否比 NodeJS 更优秀的服务端 js 编程框架
- [ ] 关于 http://www.bootcss.com/ 的学习
- [ ] 腾讯Alloy Team 团队 Kinvix[a]QQ.com
- [ ] layui -- 最懂你的弹窗 -- 基于jq -- 满足你所有想要的弹窗
- [ ] [前端的一些汇总](https://github.com/helloqingfeng)
- [ ] 写简历
- [ ] TypeScript
- [ ] ES6
- [ ] 编辑器 Sublime Atom WebStorm
- [ ] [egg](https://egghead.io/)
- [ ] [slidejs](http://slidesjs.com/)
- [ ] [jquery.fullpage.min.js](http://www.dowebok.com/demo/2014/77/)
- [ ] [谷歌浏览器插件开发](http://open.chrome.360.cn/extension_dev/overview.html)


1.跟LESS和Sass让书写CSS变得更容易一样,CoffeeScript简化了书写JavaScript的方式。
2.项目管理工具：gulp,grunt,webpack、Node.js，PHP，Angular，Gulp，Webpack。
3.了解backbone,Underscore,angular,react,vue,ember,jQuery、sass、CoffeeScript、Bootstrap等；
4.koala是一个前端预处理器语言图形编辑工具，支持Less,sass,compass,coffeescript,帮助web开发者更高效的使用它们进行开发。跨平台运行，完美兼容windows,linux,mac。
6.《锋利的jQuery》342页的浏览器中的调试以及断点，值得学习，总结一篇blog。
7.关于一些作者草稿区中的文章[https://github.com/yalishizhude/Github-blog/tree/master/source/_drafts](https://github.com/yalishizhude/Github-blog/tree/master/source/_drafts)

鸭子类型 [维基百科](https://zh.wikipedia.org/zh-cn/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B)
在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由"当前方法和属性的集合"决定。这个概念的名字来源于由James Whitcomb Riley提出的鸭子测试（见下面的“历史”章节），“鸭子测试”可以这样表述：
“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”[1][2]
在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为"鸭子"的对象，并调用它的"走"和"叫"方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的"走"和"叫"方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的"走"和"叫"方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。
鸭子类型通常得益于"不"测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性。

那么，我的理解是 鸭子类型 这种可能在弱类型中比较常见。在强类型语言中应该不存在。

我们定义一个函数，传入鸭子对象，并调用它的 走 方法。
如果我们传入一个 鸟 对象，如果它有 走 这个方法，那么，我们这个函数依然可以正常运行，如果 鸟 对象，没有 走 方法，那么将引发一个运行时错误。





js - onclick和addEventListener和attachEvent有什么区别呢？
本质的区别是el.onclick相当于在标签上写onclick，用addEventListener和attachEvent是通过DOM接口去绑定事件。
一个html文档的解析是有顺序的，先解析标签项，再解析DOM项，el.onlick事实上相当于写在标签页上，通过标签的onclick属性输入到文档，然后由文档解析成事件的。而后者，要在文档解析完成以后，通过文档的dom接口去绑定的事件，虽然结果是一样的，都是click事件，但是过程是不同的。

通过这三种方式绑定的事件，怎么取消呢？
el.onclick: el.onclick = null;这样就可以取消绑定在el上的事件处理程序了。
通过addEventListener()添加的事件处理程序只能通过removeEventListener()来移除，并且移除时传入的参数与添加处理程序时使用的参数相同。通过addEventListener()添加的匿名函数将无法移除。
通过attachEvent()添加的事件处理程序要通过detachEvent()来移除，其他的情况和addEventListener()一样。


如果都想在事件函数里面获取event对象，怎么获取呢？
这要分浏览器，IE和非IE的事件对象不同。兼容DOM的浏览器会将一个event对象传入到事件处理程序中，无论指定事件处理程序时使用什么方法，都会传入event对象。
```
el.onclick = function(event) {
    alert(event.type);  //'click'
}
el.addEventListener("click",function(event) {
    alert(event.type);  //'click'
},false);
```

通过HTML标签属性指定的事件处理程序时，变量event中保存着event对象。
`<input type="button" value="Click me" onclick="alert(event.type)/>  //"click"`
在IE中，要访问event对象有几种不同的方式：
通过el.onclick绑定的事件处理程序中，event对象作为window对象的一个属性存在。
```
el.onclick = function() {
    var event = window.event;
    alert(event.type);  //"click"
}
```
如果通过attachEvent()添加事件处理程序时，event对象作为参数被传入事件处理程序，
```
el.attachEvent("onclick",function(event) {
    alert(event.type);  //"click"
});
```
通过HTML标签属性指定的事件处理程序时，变量event中保存着event对象。这点和非IE一样。
综上，跨浏览器的事件对象获取方法是：return event?event:window.event;




移动端web app是什么呢？简单理解就是页面头部加入了下面这一句话的东西：
```
<meta name="apple-mobile-web-app-capable" content="yes">
```
这个meta的作用是让普通移动网页被添加到主屏幕后，拥有一些类native的功能，很多同学应该都很熟悉了。就是类似隐藏ios的上下状态栏，实现全屏，禁止弹性拖拽，全屏，修改顶部颜色等。




关于sass中以%为单位的做法：
width: percentage(100/4 * $i/100);    //多除一个100然是使用percentage()。

[关于blog中摘要显示图片，点击进去以后不显示图片](http://www.wellliu.com/2016/12/30/%E3%80%90%E8%BD%AC%E3%80%91Blog%E6%91%98%E8%A6%81%E9%85%8D%E5%9B%BE/#more)

关于输入框只能输入数字或者电话号码，最好的做法不是keycode。而是使用正则。
```

<html>
<body>
<script type="text/javascript">
function noNumbers(e)
{
var keynum
var keychar
var numcheck

if(window.event) // IE
  {
  keynum = e.keyCode
  }
else if(e.which) // Netscape/Firefox/Opera
  {
  keynum = e.which
  }
keychar = String.fromCharCode(keynum)
numcheck = /\d/
return !numcheck.test(keychar)
}
</script>

<form>
<input type="text" onkeypress="return noNumbers(event)" />
</form>

</html>
```


[JS改变input的value值不触发onchange事件解决方案](http://blog.csdn.net/zhbitxhd/article/details/12943091)
onchange 改变以后，还必须失去焦点才行。
还有这篇文章也一起看一下：[实时监听输入框值变化的完美方案：oninput & onpropertychange](http://www.cnblogs.com/lhb25/archive/2012/11/30/oninput-and-onpropertychange-event-for-input.html)




关于 `<head>` 标签，HTML 与 XHTML 之间的差异是 NONE。
[关于 HTML 页面 meta 标签内容详解](http://www.cnblogs.com/zhang-jian/p/4936479.html)




$.ajax()方法是$.get、$.post等一系列方法的基础。
``` javascript
getJSON: function(url,data,callback) {
    return jQuery.get(url,data,callback,"json");
}

get: function(url,data,callback,type) {
    // shift arguments if data argument was omited
    if(jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = null;
    }
    return jQuery.ajax({
        type: "GET",
        url: url,
        data: data,
        success: callback,
        dataType: type
    });
}
```



[这个人的博客不错，取其精华](http://www.cnblogs.com/shytong/p/5901753.html)



Flash/SilverLight跨域
浏览器的各种插件也存在跨域需求。通常是通过在服务器配置crossdomain.xml，设置本服务允许哪些域名的跨域访问。
客户端会首先请求此文件，如果发现自己的域名在访问列表里，就发起真正的请求，否则不发送请求。
``` xml
<?xml version="1.0"?>
  <!DOCTYPE cross-domain-policy SYSTEM "http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd">
    <cross-domain-policy>
      <allow-access-from domain="*"/>
      <allow-http-request-headers-from domain="*" headers="*"/>
    </cross-domain-policy>
```


互联网的发展催生了跨域访问的需求，各种跨域方法和协议满足了需求但也增加了各种风险。尤其是XSS和CSRF等攻击的盛行也得益于此。了解这些技术背景有助于在实际项目中熟练应用并规避各种安全风险。


[You might not need jquery](http://youmightnotneedjquery.com/)




console.log 用法还是挺丰富的：http://www.alloyteam.com/2013/11/console-log/


